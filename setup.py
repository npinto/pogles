# This is the distutils setup script for pogles.
#
# Copyright (c) 2013 Riverbank Computing Limited.


import glob
import os
import shutil
import sys

from distutils.core import setup, Extension
from distutils.errors import DistutilsExecError, DistutilsFileError


# Define constants.
SIP_MIN_VERSION = (4, 14, 2)

# Initialise globals.
cmdclass = {}
command_options = {}


# The version number.
from pogles import __version__ as version


# Try and work out the platform.
if os.access('/opt/vc/include/bcm_host.h', os.F_OK):
    platform = 'rpi'
    platform_tag = 'PP_RPI'
    platform_libraries = ['bcm_host']
    include_dirs = ['/opt/vc/include',
            '/opt/vc/include/interface/vcos/pthreads']
    library_dirs = ['/opt/vc/lib']
else:
    # The most common and generic platform is X11 so default to it.
    platform = 'x11'
    platform_tag = 'PP_X11'
    platform_libraries = ['X11']
    include_dirs = []
    library_dirs = []


# The sip command line flags.
sip_opts = ['-o', '-t', platform_tag]

if sys.hexversion < 0x03000000:
    sip_opts.extend(['-x', 'Py_v3'])

# Define the extension modules.
platform_mod = Extension('platform',
        ['sip/platform/%s/pp_%s.sip' % (platform, platform)],
        swig_opts=sip_opts, include_dirs=include_dirs,
        library_dirs=library_dirs, libraries=platform_libraries)

egl_mod = Extension('egl', ['sip/egl/egl.sip'], swig_opts=sip_opts,
        include_dirs=include_dirs, library_dirs=library_dirs,
        libraries=['EGL', 'GLESv2'])

gles2_mod = Extension('gles2', ['sip/gles2/gles2.sip'], swig_opts=sip_opts,
        include_dirs=include_dirs, library_dirs=library_dirs,
        libraries=['GLESv2'])

# Define a build extension command that builds a SIP generated extension.
from distutils.command.build_ext import build_ext as build_ext_base

class build_ext(build_ext_base):
    """ The Command sub-class that builds SIP generated extensions. """

    # The user options are the standard ones with the SWIG related ones
    # removed and SIP related ones added.
    user_options = [opt for opt in build_ext_base.user_options if not opt[0].startswith('swig')]
    user_options += [('sip=', None, "path to the SIP executable")]

    def initialize_options (self):
        """ Reimplemented to initialise the SIP related options. """

        build_ext_base.initialize_options(self)

        self.sip = None

    def run(self):
        """ Reimplemented to check for the SIP executable. """

        self._check_sip()

        build_ext_base.run(self)

    def swig_sources(self, sources, extension):
        """ Reimplemented to update the list of sources with those generated by
        SIP.
        """

        new_sources = []

        for source in sources:
            (path, ext) = os.path.splitext(source)
            if ext == '.sip':
                # Create an empty temporary directory for the generated files.
                temp = os.path.join(self.build_temp, os.path.basename(path))
                try:
                    shutil.rmtree(temp)
                except:
                    pass

                os.makedirs(temp)

                sip_cmd = [self.sip, '-c', temp] + extension.swig_opts + [source]
                self.spawn(sip_cmd)

                new_sources += glob.glob(os.path.join(temp, '*.c'))
            else:
                new_sources.append(source)

        return new_sources

    def _check_sip(self):
        """ Check that the SIP executable can be found and that it is good
        enough.
        """

        if self.sip is None:
            self.sip = self._find_exe('sip')

        if self.sip is None:
            raise DistutilsFileError(
                    "make sure you have a working sip on your PATH or use the "
                    "--sip argument to the build_ext command to explicitly "
                    "specify a working sip")

        pipe = os.popen(' '.join([self.sip, '-V']))

        for l in pipe:
            version_str = l.strip()
            break
        else:
            raise DistutilsExecError(
                    "'%s -V' did not generate any output" % self.sip)

        pipe.close()

        if 'snapshot' not in version_str:
            try:
                version = [int(part) for part in version_str.split('.')]
            except ValueError:
                version = None

            if version is None:
                raise DistutilsExecError(
                        "'%s -V' generated unexpected output: '%s'" % (
                                self.sip, version_str))

            version = tuple(version)

            if version < SIP_MIN_VERSION:
                raise DistutilsFileError(
                        "SIP v%s or later is required" %
                                '.'.join([str(part) for part in SIP_MIN_VERSION]))

    @staticmethod
    def _find_exe(exe):
        """ Find an executable, ie. the first on the path. """

        try:
            path = os.environ['PATH']
        except KeyError:
            path = ''

        if sys.platform == 'win32':
            exe = exe + '.exe'

        for d in path.split(os.pathsep):
            exe_path = os.path.join(d, exe)

            if os.access(exe_path, os.X_OK):
                return exe_path

        return None

cmdclass['build_ext'] = build_ext


# If Sphinx is available then allow the HTML documentation to be built.
try:
    from sphinx.setup_command import BuildDoc

    cmdclass['build_sphinx'] = BuildDoc
    command_options['build_sphinx'] = {
        'release': ('setup.py', version),
        'version': ('setup.py', version)}

except ImportError:
    pass


# Define a clean command that cleans everything.
from distutils.command.clean import clean
from distutils.dir_util import remove_tree
from distutils import log

class full_clean(clean):

    def run(self):

        # Do the standard cleaning.
        clean.run(self)

        for d in ('build', 'dist', 'pogles/__pycache__'):
            if os.path.exists(d):
                remove_tree(d, dry_run=self.dry_run)

        for f in ('MANIFEST', 'pogles/__init__.pyc'):
            if not self.dry_run:
                try:
                    os.remove(f)
                    log.info("removing '%s'", f)
                except OSError:
                    pass

cmdclass['clean'] = full_clean


# Get the long description for PyPI.
with open('README') as readme:
    long_description = readme.read()


# Do the setup.
setup(
        name='pogles',
        version=version,
        description='Python Bindings for OpenGL ES v2.0',
        long_description=long_description,
        author='Riverbank Computing Limited',
        author_email='info@riverbankcomputing.com',
        url='http://www.riverbankcomputing.com/software/pogles/',
        license='BSD',
        platforms=['X11', 'Raspberry Pi'],
        packages=['pogles'],
        ext_package='pogles',
        ext_modules=[platform_mod, egl_mod, gles2_mod],
        cmdclass=cmdclass,
        command_options=command_options
     )
